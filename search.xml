<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>认识windows域</title>
    <url>/2023/10/31/windows%E5%9F%9F%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="windows域的概念"><a href="#windows域的概念" class="headerlink" title="windows域的概念"></a>windows域的概念</h1><h2 id="域的概念（concept）"><a href="#域的概念（concept）" class="headerlink" title="域的概念（concept）"></a>域的概念（concept）</h2><p>域是计算机网络的一种形式，其中所有用户账户，计算机，打印机和其他安全主体都位于域控制器里的一个或多个中央计算机集群上的中央数据库中注册。身份验证也位于域控制器上进行。</p>
<p><em><strong>域（domain）相当于一个升级的工作组</strong></em></p>
<p>域是一个拥有安全边界的计算机集合，一个域无法访问另一个域的资源。</p>
<p><em><strong>域控制器（domain controller,dc） 相当于域中的一台管理服务器的计算机（部门老大）</strong></em></p>
<p><em><strong>域控制器里面存在这个域中的账户密码，属于这个域的计算机登信息构成的数据库。</strong></em></p>
<p>计算机如果要连接这个域，域控制器就要鉴别这台计算机是否属于这个域，以及用户使用的登录账号是否存在，密码是否正确，如果以上信息有一项不正确，域控制器就会拒绝这台计算机登录，也不能访问这个资源。</p>
<p>域控制器是整个域的通信枢纽，所有权限身份验证都在域控制器上进行，所有域内所有验证身份的账户密码散列值都在域控制器里。</p>
<h2 id="单域"><a href="#单域" class="headerlink" title="单域"></a>单域</h2><p>通常在一个地理位置固定的小公司里，一个域就可以满足需求，在一个域内，一般要至少两台域服务器，一台作为DC，另一台作为备份DC。一般情况下，dc又是域控也会当作域名服务器使用。</p>
<p><img src="C:\Users\HUANGZHIXIAN\AppData\Roaming\Typora\typora-user-images\image-20231012173843455.png" alt="image-20231012173843455"></p>
<h2 id="父域和子域"><a href="#父域和子域" class="headerlink" title="父域和子域"></a>父域和子域</h2><h2 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h2><p>多个父域子域组成的</p>
<p>人多了，单域无法满足</p>
<p>森林</p>
<h1 id="搭建域环境"><a href="#搭建域环境" class="headerlink" title="搭建域环境"></a>搭建域环境</h1><p>条件：</p>
<p>域控+域内主机+域内主机</p>
<h2 id="活动目录（类似于DC的数据库）"><a href="#活动目录（类似于DC的数据库）" class="headerlink" title="活动目录（类似于DC的数据库）"></a>活动目录（类似于DC的数据库）</h2><p>ad就是提供目录服务的组件</p>
<p>目录用于存储有关网络对象的信息，可以管理组</p>
<h2 id="组织单元（OU）容器可部署策略，domain-controller"><a href="#组织单元（OU）容器可部署策略，domain-controller" class="headerlink" title="组织单元（OU）容器可部署策略，domain controller"></a>组织单元（OU）容器可部署策略，domain controller</h2><h2 id="委派控制"><a href="#委派控制" class="headerlink" title="委派控制"></a>委派控制</h2>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/31/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84/</url>
    <content><![CDATA[<hr>
<h2 id="title：工作组的含义"><a href="#title：工作组的含义" class="headerlink" title="title：工作组的含义"></a>title：工作组的含义</h2><h2 id="什么是组"><a href="#什么是组" class="headerlink" title="什么是组"></a>什么是组</h2><p>每个部门为了完成相应的工作而布置分配的小组，便于管理和分配电脑以及网络</p>
<h2 id="加入工作组"><a href="#加入工作组" class="headerlink" title="加入工作组"></a>加入工作组</h2><p>更改已有的工作组名称</p>
<h2 id="创建工作组"><a href="#创建工作组" class="headerlink" title="创建工作组"></a>创建工作组</h2><p><img src="C:\Users\HUANGZHIXIAN\AppData\Roaming\Typora\typora-user-images\image-20231012164703499.png" alt="image-20231012164703499"></p>
<p>没有的新工作组更改会创建</p>
<p>重启</p>
<h2 id="退出工作组"><a href="#退出工作组" class="headerlink" title="退出工作组"></a>退出工作组</h2><p>改掉名称就行，工作组就如一个社团一样 </p>
<h2 id="工作组优缺点"><a href="#工作组优缺点" class="headerlink" title="工作组优缺点"></a>工作组优缺点</h2><p>优点</p>
<p>1.方便管理维护</p>
<p>2.资源分配灵活方便</p>
<p>缺点</p>
<p>1.缺乏集中管理和控制机制</p>
<p>2.没有集中的统一账户管理</p>
<p>3.知识和小规模用户的使用  </p>
<h2 id="如何访问？"><a href="#如何访问？" class="headerlink" title="如何访问？"></a>如何访问？</h2><p>图形化：进入网络，输入账号密码，内网</p>
<p>高级共享设置可以设置网络，共享，密码保护</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/31/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/11/02/Python-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<hr>
<h2 id="title-Python-面向过程编程笔记"><a href="#title-Python-面向过程编程笔记" class="headerlink" title="title:Python 面向过程编程笔记"></a>title:Python 面向过程编程笔记</h2><h1 id="PYTHON"><a href="#PYTHON" class="headerlink" title="PYTHON"></a>PYTHON</h1><h2 id="1-先说什么是面向过程和面向对象"><a href="#1-先说什么是面向过程和面向对象" class="headerlink" title="1.先说什么是面向过程和面向对象"></a>1.先说什么是面向过程和面向对象</h2><ol>
<li>面向过程：面向过程编程是一种基于过程或函数的编程范式。在面向过程编程中，程序主要由一系列函数或过程组成，这些函数用于执行特定的任务。<strong>程序的控制流是线性的，从一个函数调用到另一个函数，依次执行。通常数据以全局变量或局部变量的形式存储，而函数则操作这些数据。</strong>针对过程编程强调程序的步骤和过程，而不关注数据的抽象和封装。</li>
<li>面向对象：面向对象编程是一种<strong>以对象为中心</strong>的编程范式。在面向对象编程中，程序通过创建和操作对象来实现功能。<strong>对象是具有状态（属性）和行为（方法）的实体，它们可以面向对象编程数据增强的抽象和封装，以及通过类来定义对象的模板。类是对象的蓝图，定义了对象的属性和方法</strong>。面向对象编程有主要的四个结构：封装、继承、多状态和抽象。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/11/09/leetcode%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<hr>
<h2 id="title：leetcode-简单题之两数之和-python解法"><a href="#title：leetcode-简单题之两数之和-python解法" class="headerlink" title="title：leetcode 简单题之两数之和 python解法"></a>title：leetcode 简单题之两数之和 python解法</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><em><strong>题目</strong></em></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span><br><span class="line"></span><br><span class="line">你可以按任意顺序返回答案。</span><br></pre></td></tr></table></figure>

<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a><em><strong>思路分析</strong></em></h3><p>这道题没有难度，主要考验的是对循环的使用，内嵌套一个双循环，定一个外层内层循环，再遍历内循环，去一一对比两数之和等于目标值的序号，结果返回序号就行。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a><em><strong>题解</strong></em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> nums[i]+ nums[j] ==target:</span><br><span class="line">                    <span class="keyword">return</span> [i,j]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/11/09/python%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<hr>
<h2 id="title-装饰器-迭代器-生成器"><a href="#title-装饰器-迭代器-生成器" class="headerlink" title="title:装饰器 + 迭代器+生成器"></a>title:装饰器 + 迭代器+生成器</h2><h1 id="装饰器的功能"><a href="#装饰器的功能" class="headerlink" title="装饰器的功能"></a>装饰器的功能</h1><p>可以添加模块以外的各种小功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#！/usr/bin/env python3 #指定解释器</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">   		<span class="built_in">print</span>(<span class="string">&#x27;function&#x27;</span> + func.__name__ + <span class="string">&#x27; has been called at &#x27;</span>+ datetime.now().strftime (<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>)</span><br><span class="line">	<span class="keyword">return</span> x+y</span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;___________test__________&#x27;</span>)</span><br><span class="line">test()</span><br><span class="line">add(<span class="number">7</span>,<span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>装饰器就是把不改变原函数功能情况下再次添加一些功能</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>什么是迭代器，什么是可迭代对象，一个一个读取操作对象就是迭代，可迭代对象就是for循环可以读的元素就是迭代。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比如 数组，元组，字典，列表，</span><br></pre></td></tr></table></figure>

<p>迭代器可以用next获取下一个值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">letter= [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="comment">#for l in letter:</span></span><br><span class="line"><span class="comment">#    print(l)</span></span><br><span class="line">it= <span class="built_in">iter</span>(letter)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line">结果为</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<p>原理代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        self.a +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.a &gt; self.b:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="keyword">return</span> self.a</span><br><span class="line">test = Test(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(test.__next__())</span><br><span class="line"><span class="built_in">print</span>(test.__next__())</span><br><span class="line"><span class="built_in">print</span>(test.__next__())</span><br><span class="line"><span class="built_in">print</span>(test.__next__())</span><br><span class="line"><span class="built_in">print</span>(test.__next__())</span><br><span class="line"><span class="built_in">print</span>(test.__next__())</span><br><span class="line"><span class="built_in">print</span>(test.__next__())</span><br><span class="line"><span class="built_in">print</span>(test.__next__())</span><br><span class="line"><span class="built_in">print</span>(test.__next__())</span><br></pre></td></tr></table></figure>

<h1 id="生成器interation"><a href="#生成器interation" class="headerlink" title="生成器interation"></a>生成器interation</h1><p>生成器首先得是一个迭代器，生成器是动态的，随时可以生成的，如果迭代对象很多，使用生成器可以节省很多内存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = (x**x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> g:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>

<p>用yield编写生成器和ruturn 返回对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#斐波拉契数列生成</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    current =<span class="number">0</span></span><br><span class="line">    a,b = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> current &lt; n:</span><br><span class="line">        <span class="keyword">yield</span>  a</span><br><span class="line">        a,b = b, a+b</span><br><span class="line">        current +=<span class="number">1</span></span><br><span class="line">f10=fib(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f10:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
